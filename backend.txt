===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\.github\workflows\deploy.yml =====
name: Deploy Backend to EC2

on:
  push:
    branches: ["main"]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Copy project files via SCP
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        source: "."
        target: "/home/ubuntu/bot-sales-backend"

    - name: Install dependencies and restart backend
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          cd /home/ubuntu/bot-sales-backend
          npm install --production
          pm2 restart bot-sales-backend || pm2 start server.js --name bot-sales-backend
          pm2 save



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\.github\workflows\test-ssh.yml =====
name: Test SSH to EC2

on:
  workflow_dispatch:   # Permite ejecutarlo manualmente

jobs:
  ssh-test:
    runs-on: ubuntu-latest
    steps:
      - name: Test SSH connection
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "🎯 Conexión SSH exitosa!"
            hostname
            uptime



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\config\db.js =====
// src/config/db.js
import mongoose from "mongoose";

const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true });
        console.log("MongoDB connected");
    } catch (err) {
        console.error("MongoDB connection error:", err);
        process.exit(1);
    }
};

export default connectDB;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\controllers\auth.controller.js =====
import User from "../models/User.js";
import UserLog from "../models/UserLog.js"; 
import generateToken from "../utils/generateToken.js";

// REGISTRO WEB
export const register = async (req, res) => {
    try {
        const { name, email, password } = req.body;
        if (!name || !email || !password) return res.status(400).json({ msg: "Faltan campos" });

        const exists = await User.findOne({ email });
        if (exists) return res.status(400).json({ msg: "Email registrado" });

        const user = await User.create({ name, email, password, role: "admin", source: "web" });

        // LOG
        await UserLog.create({
            userId: user._id,
            action: "REGISTER",
            source: "web",
            details: "Admin registrado en Web",
            ip: req.ip
        });

        const token = generateToken(user);
        res.status(201).json({ user: { id: user._id, name: user.name, email: user.email, role: user.role }, token });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

// LOGIN WEB
export const login = async (req, res) => {
    try {
        const { email, password } = req.body;
        if (!email || !password) return res.status(400).json({ msg: "Faltan campos" });

        const user = await User.findOne({ email }).select("+password");
        if (!user) return res.status(400).json({ msg: "Credenciales inválidas" });

        const match = await user.matchPassword(password);
        if (!match) return res.status(400).json({ msg: "Credenciales inválidas" });

        if (user.role !== "admin") return res.status(403).json({ msg: "Acceso denegado" });

        user.lastLogin = new Date();
        await user.save();

        // LOG
        await UserLog.create({
            userId: user._id,
            action: "LOGIN",
            source: "web",
            details: "Login en Dashboard",
            ip: req.ip
        });

        const token = generateToken(user);
        res.json({ user: { id: user._id, name: user.name, email: user.email, role: user.role }, token });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

// TELEGRAM AUTH
export const telegramAuth = async (req, res) => {
    try {
        const { telegramId, telegramUsername, name, email, password, avatar } = req.body;

        if (!telegramId) return res.status(400).json({ msg: "telegramId required" });

        let user = await User.findOne({ telegramId });

        if (user) {
            // SEGURIDAD ESTRICTA
            if (user.source === "web" || user.role === "admin") {
                return res.status(403).json({ msg: "Cuenta administrativa. Use panel web." });
            }

            user.lastLogin = new Date();
            if (avatar) user.avatar = avatar;
            if (password) user.password = password;
            
            await user.save();

            // LOG
            await UserLog.create({
                userId: user._id,
                action: "LOGIN",
                source: "telegram",
                details: `Login bot: ${telegramUsername || name}`
            });

            const token = generateToken(user);
            return res.json({ 
                user: { id: user._id, name: user.name, telegramId: user.telegramId, role: user.role, avatar: user.avatar }, 
                token 
            });
        }

        // REGISTRO NUEVO
        if (email) {
            const emailExists = await User.findOne({ email });
            if (emailExists) return res.status(400).json({ msg: "Email ya registrado." });
        }

        const newUser = await User.create({ 
            name: name || `tg_${telegramId}`, 
            telegramId, 
            telegramUsername, 
            email,       
            password,    
            avatar: avatar || "",
            role: "user", 
            source: "telegram",
            lastLogin: new Date()
        });

        // LOG
        await UserLog.create({
            userId: newUser._id,
            action: "REGISTER",
            source: "telegram",
            details: "Registro desde Telegram"
        });

        const token = generateToken(newUser);
        res.status(201).json({ 
            user: { id: newUser._id, name: newUser.name, telegramId: newUser.telegramId, role: newUser.role, avatar: newUser.avatar }, 
            token 
        });

    } catch (err) {
        console.error(err);
        res.status(500).json({ msg: err.message });
    }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\controllers\cart.controller.js =====
// src/controllers/cart.controller.js
import Cart from "../models/Cart.js";
import Product from "../models/Product.js";

/**
 * userId: string (telegramId or internal)
 */
export const getCart = async (req, res) => {
    const userId = req.params.userId || req.query.userId;
    if (!userId) return res.status(400).json({ msg: "userId required" });
    const cart = await Cart.findOne({ userId }).populate("items.productId");
    if (!cart) return res.json({ userId, items: [] });
    res.json(cart);
};

export const addToCart = async (req, res) => {
    try {
        const { userId, productId, quantity = 1 } = req.body;
        if (!userId || !productId) return res.status(400).json({ msg: "Missing data" });
        const product = await Product.findById(productId);
        if (!product) return res.status(404).json({ msg: "Product not found" });
        if (product.stock < quantity) return res.status(400).json({ msg: "Not enough stock" });

        let cart = await Cart.findOne({ userId });
        if (!cart) {
            cart = await Cart.create({ userId, items: [{ productId, quantity }] });
        } else {
            const idx = cart.items.findIndex(it => it.productId.toString() === productId);
            if (idx === -1) cart.items.push({ productId, quantity });
            else cart.items[idx].quantity += quantity;
            cart.updatedAt = new Date();
            await cart.save();
        }
        const populated = await Cart.findById(cart._id).populate("items.productId");
        res.json(populated);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

export const updateCartItem = async (req, res) => {
    try {
        const { userId } = req.params;
        const { productId, quantity } = req.body;
        if (!productId) return res.status(400).json({ msg: "Missing productId" });
        const cart = await Cart.findOne({ userId });
        if (!cart) return res.status(404).json({ msg: "Cart not found" });
        const item = cart.items.find(it => it.productId.toString() === productId);
        if (!item) return res.status(404).json({ msg: "Item not found" });

        if (quantity <= 0) {
            cart.items = cart.items.filter(it => it.productId.toString() !== productId);
        } else {
            const product = await Product.findById(productId);
            if (!product) return res.status(404).json({ msg: "Product not found" });
            if (product.stock < quantity) return res.status(400).json({ msg: "Not enough stock" });
            item.quantity = quantity;
        }
        cart.updatedAt = new Date();
        await cart.save();
        const populated = await Cart.findById(cart._id).populate("items.productId");
        res.json(populated);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

export const clearCart = async (req, res) => {
    try {
        const { userId } = req.params;
        await Cart.findOneAndDelete({ userId });
        res.json({ ok: true });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\controllers\category.controller.js =====
// src/controllers/category.controller.js
import Category from "../models/Category.js";

export const listCategories = async (req, res) => {
    try {
        const cats = await Category.find().sort({ name: 1 });
        res.json(cats);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

export const createCategory = async (req, res) => {
    try {
        const { name, description } = req.body;
        const c = await Category.create({ name, description });
        res.status(201).json(c);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

export const updateCategory = async (req, res) => {
    try {
        const { name, description } = req.body;
        const c = await Category.findByIdAndUpdate(req.params.id, { name, description }, { new: true });
        if (!c) return res.status(404).json({ msg: "Not found" });
        res.json(c);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

export const deleteCategory = async (req, res) => {
    try {
        const d = await Category.findByIdAndDelete(req.params.id);
        if (!d) return res.status(404).json({ msg: "Not found" });
        res.json({ ok: true });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\controllers\chatbot.controller.js =====
// src/controllers/chatbot.controller.js
import Conversation from "../models/Conversation.js";
import Cart from "../models/Cart.js";
import Product from "../models/Product.js";
import recommendationEngine from "../services/recommendationEngine.js";
import { addToCart } from "./cart.controller.js";
import { createSale } from "./sale.controller.js";
import chatbotFormatter from "../services/chatbotFormatter.js";

/**
 * Receive message (n8n will call this to gather context to include in prompt)
 */
export const receiveMessage = async (req, res) => {
    try {
        const { userId, message, metadata } = req.body;
        if (!userId || !message) return res.status(400).json({ msg: "Missing userId or message" });

        let conv = await Conversation.findOne({ userId });
        if (!conv) conv = await Conversation.create({ userId, messages: [{ from: "user", text: message, metadata }] });
        else { conv.messages.push({ from: "user", text: message, metadata }); conv.updatedAt = new Date(); await conv.save(); }

        const cart = await Cart.findOne({ userId }).populate("items.productId");
        const recommended = await recommendationEngine.suggestFromMessage(message);

        const formatted = chatbotFormatter.formatForAgent({ conversation: conv, latestMessage: message, cart, recommended });
        res.json(formatted);
    } catch (err) { res.status(500).json({ msg: err.message }); }
};

/**
 * tool executor (will be protected by checkSecret in routes)
 */
export const toolExecutor = async (req, res) => {
    try {
        const { toolName } = req.params;
        const payload = req.body;

        if (toolName === "addToCart") {
            // call cart controller logic
            const fakeReq = { body: payload };
            const fakeRes = {
                json: (d) => d,
                status: (s) => ({ json: (d) => { throw { status: s, data: d }; } })
            };
            try {
                const result = await addToCart(fakeReq, fakeRes);
                return res.json({ ok: true, result });
            } catch (err) {
                return res.status(err.status || 500).json(err.data || { msg: err.message || "error" });
            }
        }

        if (toolName === "createSale") {
            const fakeReq = { body: payload };
            const fakeRes = { json: (d) => d, status: (s) => ({ json: (d) => { throw { status: s, data: d }; } }) };
            try {
                const result = await createSale(fakeReq, fakeRes);
                return res.json({ ok: true, result });
            } catch (err) {
                return res.status(err.status || 500).json(err.data || { msg: err.message || "error" });
            }
        }

        if (toolName === "listProducts") {
            const { search, category, sort, limit } = payload || {};
            const q = {};
            if (category) q.category = category;
            if (search) q.name = { $regex: search, $options: "i" };
            let query = Product.find(q).limit(limit ? Number(limit) : 20);
            if (sort === "price_asc") query = query.sort({ price: 1 });
            if (sort === "price_desc") query = query.sort({ price: -1 });
            const products = await query.exec();
            return res.json({ products });
        }

        return res.status(400).json({ msg: "Tool not recognized" });
    } catch (err) { res.status(500).json({ msg: err.message }); }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\controllers\conversation.controller.js =====
// src/controllers/conversation.controller.js
import Conversation from "../models/Conversation.js";

export const getAllConversations = async (req, res) => {
    try {
        const convs = await Conversation.find().sort({ updatedAt: -1 });
        res.json(convs);
    } catch (err) { res.status(500).json({ msg: err.message }); }
};

export const getConversationByUser = async (req, res) => {
    try {
        const conv = await Conversation.findOne({ userId: req.params.userId });
        if (!conv) return res.status(404).json({ msg: "Not found" });
        res.json(conv);
    } catch (err) { res.status(500).json({ msg: err.message }); }
};

export const createOrAppendMessage = async (req, res) => {
    try {
        const { userId, from, text, metadata } = req.body;
        if (!userId || !from || !text) return res.status(400).json({ msg: "Missing fields" });
        let conv = await Conversation.findOne({ userId });
        if (!conv) conv = await Conversation.create({ userId, messages: [{ from, text, metadata }], channel: req.body.channel || "telegram" });
        else { conv.messages.push({ from, text, metadata }); conv.updatedAt = new Date(); await conv.save(); }
        res.json(conv);
    } catch (err) { res.status(500).json({ msg: err.message }); }
};

export const deleteConversation = async (req, res) => {
    try {
        const d = await Conversation.findOneAndDelete({ userId: req.params.userId });
        if (!d) return res.status(404).json({ msg: "Not found" });
        res.json({ ok: true });
    } catch (err) { res.status(500).json({ msg: err.message }); }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\controllers\product.controller.js =====
// src/controllers/product.controller.js
import Product from "../models/Product.js";
import Category from "../models/Category.js";

// 📌 LISTAR PRODUCTOS
export const listProducts = async (req, res) => {
    try {
        const { category, search, sort } = req.query;

        const q = {};
        if (category) q.category = category;
        if (search) q.name = { $regex: search, $options: "i" };

        let query = Product.find(q);

        const sortMap = {
            price_asc: { price: 1 },
            price_desc: { price: -1 },
            name_asc: { name: 1 },
            name_desc: { name: -1 },
            stock_asc: { stock: 1 },
            stock_desc: { stock: -1 },
        };

        if (sort && sortMap[sort]) query.sort(sortMap[sort]);
        else query.sort({ createdAt: -1 });

        const products = await query.exec();
        res.json(products);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

// 📌 OBTENER PRODUCTO POR ID
export const getProductById = async (req, res) => {
    try {
        const p = await Product.findById(req.params.id);
        if (!p) return res.status(404).json({ msg: "Producto no encontrado" });
        res.json(p);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

// 📌 CREAR PRODUCTO
export const createProduct = async (req, res) => {
    try {
        const { name, description, category, price, stock } = req.body;

        const catExists = await Category.findOne({ name: category });
        if (!catExists) return res.status(400).json({ msg: "La categoría no existe" });

        const p = await Product.create({ name, description, category, price, stock });
        res.json(p);

    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

// 📌 ACTUALIZAR PRODUCTO
export const updateProduct = async (req, res) => {
    try {
        const { name, description, category, price, stock } = req.body;

        const catExists = await Category.findOne({ name: category });
        if (!catExists) return res.status(400).json({ msg: "La categoría no existe" });

        const updated = await Product.findByIdAndUpdate(
            req.params.id,
            { name, description, category, price, stock },
            { new: true }
        );

        if (!updated) return res.status(404).json({ msg: "Producto no encontrado" });

        res.json(updated);

    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

// 📌 ELIMINAR PRODUCTO
export const deleteProduct = async (req, res) => {
    try {
        const deleted = await Product.findByIdAndDelete(req.params.id);
        if (!deleted) return res.status(404).json({ msg: "Producto no encontrado" });

        res.json({ msg: "Producto eliminado" });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

// 📌 MÉTRICAS DEL INVENTARIO
export const getProductMetrics = async (req, res) => {
    try {
        const totalProducts = await Product.countDocuments();
        const lowStock = await Product.find({ stock: { $lte: 5, $gt: 0 } })
            .select("name stock category");
        const outOfStock = await Product.find({ stock: 0 })
            .select("name stock category");

        res.json({
            totalProducts,
            lowStock,
            outOfStock
        });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\controllers\sale.controller.js =====
// src/controllers/sale.controller.js
import mongoose from "mongoose";
import Sale from "../models/Sale.js";
import Product from "../models/Product.js";
import Cart from "../models/Cart.js";
import Conversation from "../models/Conversation.js";

export const createSale = async (req, res) => {
    try {
        const { userId, items, payment = {}, conversationId } = req.body;
        if (!userId || !items || !Array.isArray(items) || items.length === 0) return res.status(400).json({ msg: "Invalid payload" });

        // load products
        const ids = items.map(i => i.productId);
        const products = await Product.find({ _id: { $in: ids } });

        let total = 0;
        const prepared = [];

        for (const it of items) {
            const prod = products.find(p => p._id.toString() === it.productId);
            if (!prod) return res.status(400).json({ msg: `Product ${it.productId} not found` });
            if (prod.stock < it.quantity) return res.status(400).json({ msg: `Insufficient stock for ${prod.name}` });
            prepared.push({ productId: prod._id, quantity: it.quantity, price: prod.price });
            total += prod.price * it.quantity;
        }

        // attempt to decrement stocks atomically with conditional updates
        for (const it of items) {
            const resp = await Product.updateOne({ _id: it.productId, stock: { $gte: it.quantity } }, { $inc: { stock: -it.quantity } });
            if (resp.modifiedCount === 0) return res.status(400).json({ msg: "Stock update failed due to concurrency" });
        }

        const sale = await Sale.create({ userId, items: prepared, total, payment, conversationId });

        // clear cart
        await Cart.findOneAndDelete({ userId });

        // append message to conversation if provided
        if (conversationId) {
            await Conversation.findByIdAndUpdate(conversationId, { $push: { messages: { from: "bot", text: `Venta registrada: ${sale._id}`, metadata: { saleId: sale._id } } } }, { new: true });
        }

        res.json({ sale });
    } catch (err) {
        console.error(err);
        res.status(500).json({ msg: err.message });
    }
};

export const getSales = async (req, res) => {
    try {
        // POPULATE USER: Clave para que el dashboard muestre nombres reales
        const sales = await Sale.find()
            .sort({ createdAt: -1 })
            .populate("items.productId")
            .populate("userId", "name email telegramId");
            
        res.json(sales);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

export const getMetrics = async (req, res) => {
    try {
        const totalSales = await Sale.countDocuments();
        const revenueAgg = await Sale.aggregate([{ $group: { _id: null, total: { $sum: "$total" } } }]);
        const totalRevenue = revenueAgg[0]?.total || 0;

        const byProduct = await Sale.aggregate([
            { $unwind: "$items" },
            { $group: { _id: "$items.productId", qty: { $sum: "$items.quantity" }, revenue: { $sum: { $multiply: ["$items.price", "$items.quantity"] } } } },
            { $sort: { qty: -1 } },
            { $limit: 10 }
        ]);

        const productIds = byProduct.map(b => b._id);
        const prods = await Product.find({ _id: { $in: productIds } });
        const topProducts = byProduct.map(b => {
            const p = prods.find(x => x._id.toString() === b._id.toString());
            return { productId: b._id, name: p?.name || "Desconocido", qty: b.qty, revenue: b.revenue };
        });

        res.json({ totalSales, totalRevenue, topProducts });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\controllers\user.controller.js =====
// src/controllers/user.controller.js
import User from "../models/User.js";
import Sale from "../models/Sale.js";
import UserLog from "../models/UserLog.js";
import mongoose from "mongoose";


/**
 * List users (admin)
 */
export const listUsers = async (req, res) => {
    try {
        const users = await User.find().select("-password").sort({ createdAt: -1 });
        res.json(users);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

/**
 * Create user (admin)
 */
export const createUser = async (req, res) => {
    try {
        const { name, email, password, role = "user", source = "web" } = req.body;
        if (!name) return res.status(400).json({ msg: "Name required" });
        if (email) {
            const exists = await User.findOne({ email });
            if (exists) return res.status(400).json({ msg: "Email already in use" });
        }
        const user = await User.create({ name, email, password, role, source });
        res.status(201).json({ user: { id: user._id, name: user.name, email: user.email, role: user.role, createdAt: user.createdAt } });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

/**
 * Get user by id (admin)
 */
export const getUserById = async (req, res) => {
    try {
        const u = await User.findById(req.params.id).select("-password");
        if (!u) return res.status(404).json({ msg: "User not found" });
        res.json(u);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

/**
 * Update user (admin)
 */
export const updateUser = async (req, res) => {
    try {
        const { name, email, role, status, avatar } = req.body;
        const user = await User.findById(req.params.id);
        if (!user) return res.status(404).json({ msg: "User not found" });

        if (email && email !== user.email) {
            const exists = await User.findOne({ email });
            if (exists) return res.status(400).json({ msg: "Email already in use" });
        }

        user.name = name ?? user.name;
        user.email = email ?? user.email;
        user.role = role ?? user.role;
        user.status = status ?? user.status;
        user.avatar = avatar ?? user.avatar;

        if (req.body.password) user.password = req.body.password; // will be hashed by pre-save

        await user.save();
        res.json({ msg: "User updated", user: { id: user._id, name: user.name, email: user.email, role: user.role, status: user.status } });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

/**
 * Change status (suspend/reactivate)
 */
export const changeStatus = async (req, res) => {
    try {
        const { status } = req.body; // "active" | "suspended"
        if (!["active", "suspended"].includes(status)) return res.status(400).json({ msg: "Invalid status" });

        const user = await User.findById(req.params.id);
        if (!user) return res.status(404).json({ msg: "User not found" });

        user.status = status;
        await user.save();
        res.json({ msg: "Status updated", status: user.status });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

/**
 * Delete user (admin)
 */
export const deleteUser = async (req, res) => {
    try {
        const deleted = await User.findByIdAndDelete(req.params.id);
        if (!deleted) return res.status(404).json({ msg: "User not found" });
        res.json({ msg: "User deleted" });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

/**
 * NUEVA FUNCIÓN: Obtener logs de un usuario específico
 */
export const getUserLogs = async (req, res) => {
    try {
        const { id } = req.params;
        const logs = await UserLog.find({ userId: id })
            .sort({ createdAt: -1 })
            .limit(50);
        res.json(logs);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};


/**
 * GET /users/stats
 * Returns aggregated stats per user: { _id: userId, totalCompras, totalGastado }
 */
export const getUserStats = async (req, res) => {
    try {
        const stats = await Sale.aggregate([
            {
                $group: {
                    _id: "$userId",
                    totalCompras: { $sum: 1 },
                    totalGastado: { $sum: "$total" }
                }
            }
        ]);
        res.json(stats);
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

/**
 * GET /users/:id/profile
 * Returns profile + aggregated metrics + recent sales
 */
export const getUserProfile = async (req, res) => {
    try {
        const userId = req.params.id;
        if (!mongoose.Types.ObjectId.isValid(userId)) return res.status(400).json({ msg: "Invalid id" });

        const user = await User.findById(userId).select("-password");
        if (!user) return res.status(404).json({ msg: "User not found" });

        // stats
        const agg = await Sale.aggregate([
            { $match: { userId: userId } },
            {
                $group: {
                    _id: "$userId",
                    totalCompras: { $sum: 1 },
                    totalGastado: { $sum: "$total" }
                }
            }
        ]);

        const userStats = agg[0] || { totalCompras: 0, totalGastado: 0 };

        // recent sales (last 20)
        const recentSales = await Sale.find({ userId }).sort({ createdAt: -1 }).limit(20).populate("items.productId");

        // spending by month (last 12 months)
        const now = new Date();
        const lastYear = new Date(now.getFullYear() - 1, now.getMonth() + 1, 1);
        const byMonth = await Sale.aggregate([
            { $match: { userId: userId, createdAt: { $gte: lastYear } } },
            {
                $group: {
                    _id: { year: { $year: "$createdAt" }, month: { $month: "$createdAt" } },
                    total: { $sum: "$total" },
                    count: { $sum: 1 }
                }
            },
            { $sort: { "_id.year": 1, "_id.month": 1 } }
        ]);

        res.json({
            user,
            stats: userStats,
            recentSales,
            byMonth
        });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};

/**
 * GET /users/:id/sales?page=&limit=
 * Paginated user sales
 */
export const getUserSales = async (req, res) => {
    try {
        const userId = req.params.id;
        const page = Math.max(1, Number(req.query.page || 1));
        const limit = Math.min(100, Number(req.query.limit || 20));
        const skip = (page - 1) * limit;

        const sales = await Sale.find({ userId })
            .sort({ createdAt: -1 })
            .skip(skip)
            .limit(limit)
            .populate("items.productId");

        const total = await Sale.countDocuments({ userId });

        res.json({ sales, page, limit, total });
    } catch (err) {
        res.status(500).json({ msg: err.message });
    }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\middleware\adminMiddleware.js =====
export const adminMiddleware = (req, res, next) => {
    if (!req.user) return res.status(401).json({ msg: "Unauthorized" });
    if (req.user.role !== "admin") return res.status(403).json({ msg: "Forbidden: admin only" });
    next();
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\middleware\authMiddleware.js =====
// src/middleware/authMiddleware.js
import jwt from "jsonwebtoken";
import User from "../models/User.js";

export const authMiddleware = async (req, res, next) => {
    try {
        let token = null;
        const authHeader = req.headers.authorization;
        if (authHeader && authHeader.startsWith("Bearer ")) token = authHeader.split(" ")[1];
        else if (req.headers["x-access-token"]) token = req.headers["x-access-token"];

        if (!token) return res.status(401).json({ msg: "No token" });

        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.id).select("-password");
        if (!user) return res.status(401).json({ msg: "User not found" });

        req.user = user;
        next();
    } catch (err) {
        console.error("auth error", err);
        res.status(401).json({ msg: "Invalid or expired token" });
    }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\middleware\checkSecret.js =====
// src/middleware/checkSecret.js
export const checkSecret = (req, res, next) => {
  if (!process.env.API_TOOL_SECRET) {
    console.warn("API_TOOL_SECRET not set - allowing request (not recommended)");
    return next();
  }
  const secret = req.headers["x-api-secret"] || req.body?.apiSecret;
  if (!secret || secret !== process.env.API_TOOL_SECRET) return res.status(401).json({ msg: "Invalid API Secret" });
  next();
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\middleware\roleMiddleware.js =====
// src/middleware/roleMiddleware.js

export const adminOnly = (req, res, next) => {
    if (!req.user) return res.status(401).json({ msg: "Unauthorized" });
    if (req.user.role !== "admin") return res.status(403).json({ msg: "Forbidden: admin only" });
    next();
};

export const telegramOnly = (req, res, next) => {
    if (!req.user) return res.status(401).json({ msg: "Unauthorized" });
    if (req.user.source !== "telegram" && req.user.role !== "user") return res.status(403).json({ msg: "Forbidden: telegram users only" });
    next();
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\models\Cart.js =====
import mongoose from "mongoose";

const itemSchema = new mongoose.Schema({
    productId: { type: mongoose.Schema.Types.ObjectId, ref: "Product", required: true },
    quantity: { type: Number, default: 1 }
});

const cartSchema = new mongoose.Schema({
    // RELACIÓN DEFINITIVA: ObjectId ref User
    userId: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true, index: true },
    items: [itemSchema],
    updatedAt: { type: Date, default: Date.now }
});

export default mongoose.model("Cart", cartSchema);




===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\models\Category.js =====
// src/models/Category.js
import mongoose from "mongoose";

const schema = new mongoose.Schema({
    name: { type: String, required: true, unique: true, index: true },
    description: { type: String, default: "" }
}, { timestamps: true });

export default mongoose.model("Category", schema);



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\models\Conversation.js =====
// src/models/Conversation.js
import mongoose from "mongoose";
const msgSchema = new mongoose.Schema({
    from: String,
    text: String,
    metadata: { type: Object, default: {} },
    createdAt: { type: Date, default: Date.now }
});
const convSchema = new mongoose.Schema({
    userId: { type: String, required: true, index: true },
    channel: { type: String, default: "telegram" },
    messages: [msgSchema],
    context: { type: Object, default: {} }
}, { timestamps: true });

export default mongoose.model("Conversation", convSchema);



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\models\Product.js =====
// src/models/Product.js
import mongoose from "mongoose";

const productSchema = new mongoose.Schema({
    name: { type: String, required: true, index: true },
    description: { type: String, default: "" },
    category: { type: String, default: "General", index: true },
    price: { type: Number, required: true },
    stock: { type: Number, default: 0 },
}, { timestamps: true });

export default mongoose.model("Product", productSchema);



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\models\Sale.js =====
import mongoose from "mongoose";

const saleItemSchema = new mongoose.Schema({
    productId: { type: mongoose.Schema.Types.ObjectId, ref: "Product" },
    quantity: Number,
    price: Number
});

const saleSchema = new mongoose.Schema({
    // RELACIÓN DEFINITIVA: ObjectId ref User
    userId: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
    items: [saleItemSchema],
    total: { type: Number, required: true },
    payment: {
        method: String,
        status: { type: String, enum: ["pending", "paid", "failed"], default: "paid" },
        metadata: { type: Object }
    },
    conversationId: { type: mongoose.Schema.Types.ObjectId, ref: "Conversation" }
}, { timestamps: true });

export default mongoose.model("Sale", saleSchema);



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\models\User.js =====
// src/models/User.js
import mongoose from "mongoose";
import bcrypt from "bcryptjs";

const userSchema = new mongoose.Schema(
    {
        name: { type: String, required: true },

        email: {
            type: String,
            unique: true,
            sparse: true,
        },

        telegramId: {
            type: String,
            unique: true,
            sparse: true,
        },

        password: { type: String }, // requerido solo para usuarios web

        role: {
            type: String,
            enum: ["admin", "user"],
            default: "user",
        },

        source: {
            type: String,
            enum: ["web", "telegram"],
            default: "web",
        },

        status: {
            type: String,
            enum: ["active", "suspended"],
            default: "active",
        },

        avatar: {
            type: String,
            default: "",
        },

        lastLogin: {
            type: Date,
        }
    },
    { timestamps: true }
);

// Hash de contraseña
userSchema.pre("save", async function (next) {
    if (!this.isModified("password")) return next();
    if (this.password) this.password = await bcrypt.hash(this.password, 10);
    next();
});

// Comparar contraseñas
userSchema.methods.matchPassword = function (plain) {
    return bcrypt.compare(plain, this.password);
};

export default mongoose.model("User", userSchema);



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\models\UserLog.js =====
import mongoose from "mongoose";

const userLogSchema = new mongoose.Schema({
    userId: { 
        type: mongoose.Schema.Types.ObjectId, 
        ref: "User", 
        required: true 
    },
    action: { 
        type: String, 
        enum: ["LOGIN", "REGISTER", "LOGOUT", "ERROR"], 
        required: true 
    },
    source: { 
        type: String, 
        enum: ["web", "telegram"], 
        required: true 
    },
    details: { type: String, default: "" },
    ip: { type: String, default: "" },
    
    // CAMPO EXTRA PARA LECTURA HUMANA EN BD
    dateString: { type: String }

}, { timestamps: true });

// Hook para guardar la fecha legible en hora colombiana
userLogSchema.pre("save", function(next) {
    this.dateString = new Date().toLocaleString("es-CO", { 
        timeZone: "America/Bogota",
        dateStyle: "medium",
        timeStyle: "medium"
    });
    next();
});

export default mongoose.model("UserLog", userLogSchema);



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\routes\auth.routes.js =====
// src/routes/auth.routes.js
import express from "express";
import { register, login, telegramAuth } from "../controllers/auth.controller.js";
const router = express.Router();

router.post("/register", register);
router.post("/login", login);
router.post("/telegram", telegramAuth);

export default router;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\routes\cart.routes.js =====
// src/routes/cart.routes.js
import express from "express";
import { getCart, addToCart, updateCartItem, clearCart } from "../controllers/cart.controller.js";
const router = express.Router();

router.get("/:userId", getCart);
router.post("/add", addToCart);
router.put("/:userId/item", updateCartItem);
router.delete("/:userId", clearCart);

export default router;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\routes\category.routes.js =====
// src/routes/category.routes.js
import express from "express";
import { listCategories, createCategory, updateCategory, deleteCategory } from "../controllers/category.controller.js";
import { authMiddleware } from "../middleware/authMiddleware.js";
import { adminOnly } from "../middleware/roleMiddleware.js";
const router = express.Router();

router.get("/", listCategories);
router.post("/", authMiddleware, adminOnly, createCategory);
router.put("/:id", authMiddleware, adminOnly, updateCategory);
router.delete("/:id", authMiddleware, adminOnly, deleteCategory);

export default router;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\routes\chatbot.routes.js =====
// src/routes/chatbot.routes.js
import express from "express";
import { receiveMessage, toolExecutor } from "../controllers/chatbot.controller.js";
import { checkSecret } from "../middleware/checkSecret.js";
const router = express.Router();

router.post("/message", receiveMessage);
router.post("/tool/:toolName", checkSecret, toolExecutor);

export default router;




===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\routes\conversation.routes.js =====
// src/routes/conversation.routes.js
import express from "express";
import { getAllConversations, getConversationByUser, createOrAppendMessage, deleteConversation } from "../controllers/conversation.controller.js";
import { authMiddleware } from "../middleware/authMiddleware.js";
import { adminOnly } from "../middleware/roleMiddleware.js";
const router = express.Router();

router.get("/", authMiddleware, adminOnly, getAllConversations);
router.get("/:userId", authMiddleware, getConversationByUser);
router.post("/", createOrAppendMessage); // called by n8n / chatwoot / telegram webhook
router.delete("/:userId", authMiddleware, adminOnly, deleteConversation);

export default router;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\routes\product.routes.js =====
// src/routes/product.routes.js
import express from "express";
import {
    listProducts,
    createProduct,
    getProductById,
    updateProduct,
    deleteProduct,
    getProductMetrics
} from "../controllers/product.controller.js";

import { authMiddleware } from "../middleware/authMiddleware.js";
import { adminOnly } from "../middleware/roleMiddleware.js";

const router = express.Router();

router.get("/", listProducts);
router.get("/metrics", authMiddleware, adminOnly, getProductMetrics);
router.get("/:id", getProductById);

router.post("/", authMiddleware, adminOnly, createProduct);
router.put("/:id", authMiddleware, adminOnly, updateProduct);
router.delete("/:id", authMiddleware, adminOnly, deleteProduct);

export default router;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\routes\sale.routes.js =====
// src/routes/sale.routes.js
import express from "express";
import { createSale, getSales, getMetrics } from "../controllers/sale.controller.js";
import { authMiddleware } from "../middleware/authMiddleware.js";
import { adminOnly } from "../middleware/roleMiddleware.js";
const router = express.Router();

router.post("/", createSale); // called by bot/n8n (protect with x-api-secret at router-level if desired)
router.get("/", authMiddleware, adminOnly, getSales);
router.get("/metrics", authMiddleware, adminOnly, getMetrics);

export default router;




===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\routes\user.routes.js =====
// src/routes/users.js
import express from "express";
import {
    listUsers,
    createUser,
    getUserById,
    updateUser,
    changeStatus,
    deleteUser,
    getUserStats,
    getUserProfile,
    getUserSales,
    getUserLogs
} from "../controllers/user.controller.js";
import { authMiddleware } from "../middleware/authMiddleware.js";
import { adminOnly } from "../middleware/roleMiddleware.js";

const router = express.Router();

router.get("/", authMiddleware, adminOnly, listUsers);
router.post("/", authMiddleware, adminOnly, createUser);
router.get("/stats", authMiddleware, adminOnly, getUserStats);
router.get("/:id/profile", authMiddleware, getUserProfile);
router.get("/:id/sales", authMiddleware, getUserSales);
router.get("/:id/logs", authMiddleware, adminOnly, getUserLogs); // <--- NUEVO
router.get("/:id", authMiddleware, adminOnly, getUserById);
router.put("/:id", authMiddleware, adminOnly, updateUser);
router.patch("/:id/status", authMiddleware, adminOnly, changeStatus);
router.delete("/:id", authMiddleware, adminOnly, deleteUser);   

export default router;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\services\chatbotFormatter.js =====
// src/services/chatbotFormatter.js
const chatbotFormatter = {
    productsToText(products = [], limit = 5) {
        if (!products || products.length === 0) return "No se encontraron productos.";
        const list = products.slice(0, limit).map((p, i) => `${i + 1}. ${p.name} — $${p.price} — stock: ${p.stock}`).join("\n");
        return `Te muestro los primeros ${Math.min(limit, products.length)} resultados:\n${list}`;
    },
    cartSummary(cart) {
        if (!cart || !cart.items || cart.items.length === 0) return "Tu carrito está vacío.";
        let total = 0;
        const lines = cart.items.map(it => {
            const name = it.productId?.name || "Producto";
            const price = it.productId?.price || it.price || 0;
            const qty = it.quantity;
            total += price * qty;
            return `- ${name} x${qty} — $${price * qty}`;
        });
        return `Tu carrito:\n${lines.join("\n")}\nTotal: $${total}`;
    },
    formatForAgent({ conversation, latestMessage, cart, recommended }) {
        return {
            conversationId: conversation?._id,
            context: conversation?.context || {},
            messages: conversation?.messages || [],
            latestMessage,
            cart,
            recommended,
            humanReadableCart: this.cartSummary(cart)
        };
    }
};

export default chatbotFormatter;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\services\recommendationEngine.js =====
// src/services/recommendationEngine.js
import Product from "../models/Product.js";

const guessCategoryFromText = (text = "") => {
    const t = text.toLowerCase();
    if (t.includes("auricular") || t.includes("audífono")) return "Tecnología";
    if (t.includes("camisa") || t.includes("pantalón") || t.includes("ropa")) return "Ropa";
    return null;
};

const recommendationEngine = {
    async suggestFromMessage(text = "", limit = 5) {
        const cat = guessCategoryFromText(text);
        if (!cat) return Product.find({ stock: { $gt: 0 } }).sort({ createdAt: -1 }).limit(limit).exec();
        return Product.find({ category: cat, stock: { $gt: 0 } }).limit(limit).exec();
    },
    async suggestFromCart(cart, limit = 5) {
        if (!cart || !cart.items || cart.items.length === 0) return Product.find({ stock: { $gt: 0 } }).sort({ createdAt: -1 }).limit(limit).exec();
        const categories = new Set();
        for (const it of cart.items) { const p = it.productId; if (p && p.category) categories.add(p.category); }
        const arr = Array.from(categories);
        if (arr.length === 0) return [];
        return Product.find({ category: { $in: arr }, stock: { $gt: 0 } }).limit(limit).exec();
    }
};

export default recommendationEngine;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\utils\csvExport.js =====
import XLSX from "xlsx";

export const exportToXLSX = (sales) => {
    const data = sales.map(s => ({
        id: s._id.toString(),
        userId: s.userId,
        total: s.total,
        paymentStatus: s.payment?.status || "",
        date: s.createdAt
    }));
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.json_to_sheet(data);
    XLSX.utils.book_append_sheet(wb, ws, "sales");
    return XLSX.write(wb, { type: "buffer", bookType: "xlsx" });
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\utils\generateToken.js =====
// src/utils/generateToken.js
import jwt from "jsonwebtoken";

const generateToken = (user) => {
    return jwt.sign({
        id: user._id,
        role: user.role,
        name: user.name,
        email: user.email || null,
        telegramId: user.telegramId || null,
        source: user.source || "web"
    }, process.env.JWT_SECRET, { expiresIn: "7d" });
};

export default generateToken;



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\utils\priceSortHelper.js =====
/**
 * Helper simple para mapear filtros de ordenamiento a objetos de sort de mongoose.
 */
export const mapSort = (sortKey) => {
    const map = {
        price_asc: { price: 1 },
        price_desc: { price: -1 },
        name_asc: { name: 1 },
        name_desc: { name: -1 },
        created_desc: { createdAt: -1 },
        created_asc: { createdAt: 1 }
    };
    return map[sortKey] || { createdAt: -1 };
};
/*  */



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\src\utils\stockCheck.js =====
/**
 * Utilidades para validar stock.
 * - validateItemsStock(items) : items = [{ productId, quantity }]
 *   -> lanza error con mensaje si hay insuficiente stock, o devuelve lista de productos con stock actualizado.
 */

import Product from "../models/Product.js";

export const validateItemsStock = async (items = []) => {
    if (!Array.isArray(items) || items.length === 0) return { ok: true, details: [] };

    // Cargar productos
    const ids = items.map(i => i.productId);
    const products = await Product.find({ _id: { $in: ids } });

    const details = [];

    for (const it of items) {
        const prod = products.find(p => p._id.toString() === it.productId.toString());
        if (!prod) return { ok: false, msg: `Producto ${it.productId} no existe` };
        if (prod.stock < it.quantity) return { ok: false, msg: `Stock insuficiente en ${prod.name}` };
        details.push({ productId: prod._id, stockBefore: prod.stock, willRemain: prod.stock - it.quantity });
    }

    return { ok: true, details };
};

export const deductItemsStock = async (items = []) => {
    // real deduction (use transactions if available/needed)
    for (const it of items) {
        await Product.findByIdAndUpdate(it.productId, { $inc: { stock: -it.quantity } });
    }
};



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\.env =====
PORT=4000
MONGO_URI=mongodb+srv://cristhianfelipe89:Heracotsioo6i66o52@cluster0.chann.mongodb.net/bot-sales?retryWrites=true&w=majority&appName=Cluster0
JWT_SECRET=crisalesan-unicatolica
FRONTEND_URL=http://localhost:5173
API_TOOL_SECRET=crisalesan
TZ=America/Bogota



===== SKIPPED (binary or unknown ext): C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\.env.example =====
===== SKIPPED (binary or unknown ext): C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\.gitignore =====
===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\estructura.txt =====
C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend
+ .github
  + workflows
    - deploy.yml
    - test-ssh.yml
+ src
  + config
    - db.js
  + controllers
    - auth.controller.js
    - cart.controller.js
    - category.controller.js
    - chatbot.controller.js
    - conversation.controller.js
    - product.controller.js
    - sale.controller.js
    - user.controller.js
  + middleware
    - adminMiddleware.js
    - authMiddleware.js
    - checkSecret.js
    - roleMiddleware.js
  + models
    - Cart.js
    - Category.js
    - Conversation.js
    - Product.js
    - Sale.js
    - User.js
    - UserLog.js
  + routes
    - auth.routes.js
    - cart.routes.js
    - category.routes.js
    - chatbot.routes.js
    - conversation.routes.js
    - product.routes.js
    - sale.routes.js
    - user.routes.js
  + services
    - chatbotFormatter.js
    - recommendationEngine.js
  + utils
    - csvExport.js
    - generateToken.js
    - priceSortHelper.js
    - stockCheck.js
- .env
- .env.example
- .gitignore
- estructura.txt



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\package.json =====
{
    "name": "bot-sales-backend",
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "start": "node server.js",
        "dev": "nodemon server.js"
    },
    "dependencies": {
        "bcryptjs": "^2.4.3",
        "cors": "^2.8.5",
        "dotenv": "^16.0.3",
        "express": "^4.18.2",
        "express-rate-limit": "^6.7.0",
        "helmet": "^7.0.0",
        "jsonwebtoken": "^9.0.0",
        "mongoose": "^7.2.2",
        "morgan": "^1.10.0",
        "xlsx": "^0.18.5"
    },
    "devDependencies": {
        "nodemon": "^3.0.0"
    }
}



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\pnpm-lock.yaml =====
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      bcryptjs:
        specifier: ^2.4.3
        version: 2.4.3
      cors:
        specifier: ^2.8.5
        version: 2.8.5
      dotenv:
        specifier: ^16.0.3
        version: 16.6.1
      express:
        specifier: ^4.18.2
        version: 4.21.2
      express-rate-limit:
        specifier: ^6.7.0
        version: 6.11.2(express@4.21.2)
      helmet:
        specifier: ^7.0.0
        version: 7.2.0
      jsonwebtoken:
        specifier: ^9.0.0
        version: 9.0.2
      mongoose:
        specifier: ^7.2.2
        version: 7.8.7
      morgan:
        specifier: ^1.10.0
        version: 1.10.1
      xlsx:
        specifier: ^0.18.5
        version: 0.18.5
    devDependencies:
      nodemon:
        specifier: ^3.0.0
        version: 3.1.11

packages:

  '@mongodb-js/saslprep@1.3.2':
    resolution: {integrity: sha512-QgA5AySqB27cGTXBFmnpifAi7HxoGUeezwo6p9dI03MuDB6Pp33zgclqVb6oVK3j6I9Vesg0+oojW2XxB59SGg==}

  '@types/node@24.10.1':
    resolution: {integrity: sha512-GNWcUTRBgIRJD5zj+Tq0fKOJ5XZajIiBroOF0yvj2bSU1WvNdYS/dn9UxwsujGW4JX06dnHyjV2y9rRaybH0iQ==}

  '@types/webidl-conversions@7.0.3':
    resolution: {integrity: sha512-CiJJvcRtIgzadHCYXw7dqEnMNRjhGZlYK05Mj9OyktqV8uVT8fD2BFOB7S1uwBE3Kj2Z+4UyPmFw/Ixgw/LAlA==}

  '@types/whatwg-url@8.2.2':
    resolution: {integrity: sha512-FtQu10RWgn3D9U4aazdwIE2yzphmTJREDqNdODHrbrZmmMqI0vMheC/6NE/J1Yveaj8H+ela+YwWTjq5PGmuhA==}

  accepts@1.3.8:
    resolution: {integrity: sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==}
    engines: {node: '>= 0.6'}

  adler-32@1.3.1:
    resolution: {integrity: sha512-ynZ4w/nUUv5rrsR8UUGoe1VC9hZj6V5hU9Qw1HlMDJGEJw5S7TfTErWTjMys6M7vr0YWcPqs3qAr4ss0nDfP+A==}
    engines: {node: '>=0.8'}

  anymatch@3.1.3:
    resolution: {integrity: sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==}
    engines: {node: '>= 8'}

  array-flatten@1.1.1:
    resolution: {integrity: sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg==}

  balanced-match@1.0.2:
    resolution: {integrity: sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==}

  basic-auth@2.0.1:
    resolution: {integrity: sha512-NF+epuEdnUYVlGuhaxbbq+dvJttwLnGY+YixlXlME5KpQ5W3CnXA5cVTneY3SPbPDRkcjMbifrwmFYcClgOZeg==}
    engines: {node: '>= 0.8'}

  bcryptjs@2.4.3:
    resolution: {integrity: sha512-V/Hy/X9Vt7f3BbPJEi8BdVFMByHi+jNXrYkW3huaybV/kQ0KJg0Y6PkEMbn+zeT+i+SiKZ/HMqJGIIt4LZDqNQ==}

  binary-extensions@2.3.0:
    resolution: {integrity: sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==}
    engines: {node: '>=8'}

  body-parser@1.20.3:
    resolution: {integrity: sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==}
    engines: {node: '>= 0.8', npm: 1.2.8000 || >= 1.4.16}

  brace-expansion@1.1.12:
    resolution: {integrity: sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==}

  braces@3.0.3:
    resolution: {integrity: sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==}
    engines: {node: '>=8'}

  bson@5.5.1:
    resolution: {integrity: sha512-ix0EwukN2EpC0SRWIj/7B5+A6uQMQy6KMREI9qQqvgpkV2frH63T0UDVd1SYedL6dNCmDBYB3QtXi4ISk9YT+g==}
    engines: {node: '>=14.20.1'}

  buffer-equal-constant-time@1.0.1:
    resolution: {integrity: sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==}

  bytes@3.1.2:
    resolution: {integrity: sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==}
    engines: {node: '>= 0.8'}

  call-bind-apply-helpers@1.0.2:
    resolution: {integrity: sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==}
    engines: {node: '>= 0.4'}

  call-bound@1.0.4:
    resolution: {integrity: sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==}
    engines: {node: '>= 0.4'}

  cfb@1.2.2:
    resolution: {integrity: sha512-KfdUZsSOw19/ObEWasvBP/Ac4reZvAGauZhs6S/gqNhXhI7cKwvlH7ulj+dOEYnca4bm4SGo8C1bTAQvnTjgQA==}
    engines: {node: '>=0.8'}

  chokidar@3.6.0:
    resolution: {integrity: sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==}
    engines: {node: '>= 8.10.0'}

  codepage@1.15.0:
    resolution: {integrity: sha512-3g6NUTPd/YtuuGrhMnOMRjFc+LJw/bnMp3+0r/Wcz3IXUuCosKRJvMphm5+Q+bvTVGcJJuRvVLuYba+WojaFaA==}
    engines: {node: '>=0.8'}

  concat-map@0.0.1:
    resolution: {integrity: sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==}

  content-disposition@0.5.4:
    resolution: {integrity: sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==}
    engines: {node: '>= 0.6'}

  content-type@1.0.5:
    resolution: {integrity: sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==}
    engines: {node: '>= 0.6'}

  cookie-signature@1.0.6:
    resolution: {integrity: sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ==}

  cookie@0.7.1:
    resolution: {integrity: sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==}
    engines: {node: '>= 0.6'}

  cors@2.8.5:
    resolution: {integrity: sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==}
    engines: {node: '>= 0.10'}

  crc-32@1.2.2:
    resolution: {integrity: sha512-ROmzCKrTnOwybPcJApAA6WBWij23HVfGVNKqqrZpuyZOHqK2CwHSvpGuyt/UNNvaIjEd8X5IFGp4Mh+Ie1IHJQ==}
    engines: {node: '>=0.8'}
    hasBin: true

  debug@2.6.9:
    resolution: {integrity: sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  debug@4.4.3:
    resolution: {integrity: sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  depd@2.0.0:
    resolution: {integrity: sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==}
    engines: {node: '>= 0.8'}

  destroy@1.2.0:
    resolution: {integrity: sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==}
    engines: {node: '>= 0.8', npm: 1.2.8000 || >= 1.4.16}

  dotenv@16.6.1:
    resolution: {integrity: sha512-uBq4egWHTcTt33a72vpSG0z3HnPuIl6NqYcTrKEg2azoEyl2hpW0zqlxysq2pK9HlDIHyHyakeYaYnSAwd8bow==}
    engines: {node: '>=12'}

  dunder-proto@1.0.1:
    resolution: {integrity: sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==}
    engines: {node: '>= 0.4'}

  ecdsa-sig-formatter@1.0.11:
    resolution: {integrity: sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==}

  ee-first@1.1.1:
    resolution: {integrity: sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==}

  encodeurl@1.0.2:
    resolution: {integrity: sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==}
    engines: {node: '>= 0.8'}

  encodeurl@2.0.0:
    resolution: {integrity: sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==}
    engines: {node: '>= 0.8'}

  es-define-property@1.0.1:
    resolution: {integrity: sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==}
    engines: {node: '>= 0.4'}

  es-errors@1.3.0:
    resolution: {integrity: sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==}
    engines: {node: '>= 0.4'}

  es-object-atoms@1.1.1:
    resolution: {integrity: sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==}
    engines: {node: '>= 0.4'}

  escape-html@1.0.3:
    resolution: {integrity: sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==}

  etag@1.8.1:
    resolution: {integrity: sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==}
    engines: {node: '>= 0.6'}

  express-rate-limit@6.11.2:
    resolution: {integrity: sha512-a7uwwfNTh1U60ssiIkuLFWHt4hAC5yxlLGU2VP0X4YNlyEDZAqF4tK3GD3NSitVBrCQmQ0++0uOyFOgC2y4DDw==}
    engines: {node: '>= 14'}
    peerDependencies:
      express: ^4 || ^5

  express@4.21.2:
    resolution: {integrity: sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==}
    engines: {node: '>= 0.10.0'}

  fill-range@7.1.1:
    resolution: {integrity: sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==}
    engines: {node: '>=8'}

  finalhandler@1.3.1:
    resolution: {integrity: sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==}
    engines: {node: '>= 0.8'}

  forwarded@0.2.0:
    resolution: {integrity: sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==}
    engines: {node: '>= 0.6'}

  frac@1.1.2:
    resolution: {integrity: sha512-w/XBfkibaTl3YDqASwfDUqkna4Z2p9cFSr1aHDt0WoMTECnRfBOv2WArlZILlqgWlmdIlALXGpM2AOhEk5W3IA==}
    engines: {node: '>=0.8'}

  fresh@0.5.2:
    resolution: {integrity: sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==}
    engines: {node: '>= 0.6'}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  function-bind@1.1.2:
    resolution: {integrity: sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==}

  get-intrinsic@1.3.0:
    resolution: {integrity: sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==}
    engines: {node: '>= 0.4'}

  get-proto@1.0.1:
    resolution: {integrity: sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==}
    engines: {node: '>= 0.4'}

  glob-parent@5.1.2:
    resolution: {integrity: sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==}
    engines: {node: '>= 6'}

  gopd@1.2.0:
    resolution: {integrity: sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==}
    engines: {node: '>= 0.4'}

  has-flag@3.0.0:
    resolution: {integrity: sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==}
    engines: {node: '>=4'}

  has-symbols@1.1.0:
    resolution: {integrity: sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==}
    engines: {node: '>= 0.4'}

  hasown@2.0.2:
    resolution: {integrity: sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==}
    engines: {node: '>= 0.4'}

  helmet@7.2.0:
    resolution: {integrity: sha512-ZRiwvN089JfMXokizgqEPXsl2Guk094yExfoDXR0cBYWxtBbaSww/w+vT4WEJsBW2iTUi1GgZ6swmoug3Oy4Xw==}
    engines: {node: '>=16.0.0'}

  http-errors@2.0.0:
    resolution: {integrity: sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==}
    engines: {node: '>= 0.8'}

  iconv-lite@0.4.24:
    resolution: {integrity: sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==}
    engines: {node: '>=0.10.0'}

  ignore-by-default@1.0.1:
    resolution: {integrity: sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==}

  inherits@2.0.4:
    resolution: {integrity: sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==}

  ip-address@10.1.0:
    resolution: {integrity: sha512-XXADHxXmvT9+CRxhXg56LJovE+bmWnEWB78LB83VZTprKTmaC5QfruXocxzTZ2Kl0DNwKuBdlIhjL8LeY8Sf8Q==}
    engines: {node: '>= 12'}

  ipaddr.js@1.9.1:
    resolution: {integrity: sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==}
    engines: {node: '>= 0.10'}

  is-binary-path@2.1.0:
    resolution: {integrity: sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==}
    engines: {node: '>=8'}

  is-extglob@2.1.1:
    resolution: {integrity: sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==}
    engines: {node: '>=0.10.0'}

  is-glob@4.0.3:
    resolution: {integrity: sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==}
    engines: {node: '>=0.10.0'}

  is-number@7.0.0:
    resolution: {integrity: sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==}
    engines: {node: '>=0.12.0'}

  jsonwebtoken@9.0.2:
    resolution: {integrity: sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==}
    engines: {node: '>=12', npm: '>=6'}

  jwa@1.4.2:
    resolution: {integrity: sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==}

  jws@3.2.2:
    resolution: {integrity: sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==}

  kareem@2.5.1:
    resolution: {integrity: sha512-7jFxRVm+jD+rkq3kY0iZDJfsO2/t4BBPeEb2qKn2lR/9KhuksYk5hxzfRYWMPV8P/x2d0kHD306YyWLzjjH+uA==}
    engines: {node: '>=12.0.0'}

  lodash.includes@4.3.0:
    resolution: {integrity: sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==}

  lodash.isboolean@3.0.3:
    resolution: {integrity: sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==}

  lodash.isinteger@4.0.4:
    resolution: {integrity: sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==}

  lodash.isnumber@3.0.3:
    resolution: {integrity: sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==}

  lodash.isplainobject@4.0.6:
    resolution: {integrity: sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==}

  lodash.isstring@4.0.1:
    resolution: {integrity: sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==}

  lodash.once@4.1.1:
    resolution: {integrity: sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==}

  math-intrinsics@1.1.0:
    resolution: {integrity: sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==}
    engines: {node: '>= 0.4'}

  media-typer@0.3.0:
    resolution: {integrity: sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==}
    engines: {node: '>= 0.6'}

  memory-pager@1.5.0:
    resolution: {integrity: sha512-ZS4Bp4r/Zoeq6+NLJpP+0Zzm0pR8whtGPf1XExKLJBAczGMnSi3It14OiNCStjQjM6NU1okjQGSxgEZN8eBYKg==}

  merge-descriptors@1.0.3:
    resolution: {integrity: sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==}

  methods@1.1.2:
    resolution: {integrity: sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==}
    engines: {node: '>= 0.6'}

  mime-db@1.52.0:
    resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}
    engines: {node: '>= 0.6'}

  mime-types@2.1.35:
    resolution: {integrity: sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==}
    engines: {node: '>= 0.6'}

  mime@1.6.0:
    resolution: {integrity: sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==}
    engines: {node: '>=4'}
    hasBin: true

  minimatch@3.1.2:
    resolution: {integrity: sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==}

  mongodb-connection-string-url@2.6.0:
    resolution: {integrity: sha512-WvTZlI9ab0QYtTYnuMLgobULWhokRjtC7db9LtcVfJ+Hsnyr5eo6ZtNAt3Ly24XZScGMelOcGtm7lSn0332tPQ==}

  mongodb@5.9.2:
    resolution: {integrity: sha512-H60HecKO4Bc+7dhOv4sJlgvenK4fQNqqUIlXxZYQNbfEWSALGAwGoyJd/0Qwk4TttFXUOHJ2ZJQe/52ScaUwtQ==}
    engines: {node: '>=14.20.1'}
    peerDependencies:
      '@aws-sdk/credential-providers': ^3.188.0
      '@mongodb-js/zstd': ^1.0.0
      kerberos: ^1.0.0 || ^2.0.0
      mongodb-client-encryption: '>=2.3.0 <3'
      snappy: ^7.2.2
    peerDependenciesMeta:
      '@aws-sdk/credential-providers':
        optional: true
      '@mongodb-js/zstd':
        optional: true
      kerberos:
        optional: true
      mongodb-client-encryption:
        optional: true
      snappy:
        optional: true

  mongoose@7.8.7:
    resolution: {integrity: sha512-5Bo4CrUxrPITrhMKsqUTOkXXo2CoRC5tXxVQhnddCzqDMwRXfyStrxj1oY865g8gaekSBhxAeNkYyUSJvGm9Hw==}
    engines: {node: '>=14.20.1'}

  morgan@1.10.1:
    resolution: {integrity: sha512-223dMRJtI/l25dJKWpgij2cMtywuG/WiUKXdvwfbhGKBhy1puASqXwFzmWZ7+K73vUPoR7SS2Qz2cI/g9MKw0A==}
    engines: {node: '>= 0.8.0'}

  mpath@0.9.0:
    resolution: {integrity: sha512-ikJRQTk8hw5DEoFVxHG1Gn9T/xcjtdnOKIU1JTmGjZZlg9LST2mBLmcX3/ICIbgJydT2GOc15RnNy5mHmzfSew==}
    engines: {node: '>=4.0.0'}

  mquery@5.0.0:
    resolution: {integrity: sha512-iQMncpmEK8R8ncT8HJGsGc9Dsp8xcgYMVSbs5jgnm1lFHTZqMJTUWTDx1LBO8+mK3tPNZWFLBghQEIOULSTHZg==}
    engines: {node: '>=14.0.0'}

  ms@2.0.0:
    resolution: {integrity: sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==}

  ms@2.1.3:
    resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}

  negotiator@0.6.3:
    resolution: {integrity: sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==}
    engines: {node: '>= 0.6'}

  nodemon@3.1.11:
    resolution: {integrity: sha512-is96t8F/1//UHAjNPHpbsNY46ELPpftGUoSVNXwUfMk/qdjSylYrWSu1XavVTBOn526kFiOR733ATgNBCQyH0g==}
    engines: {node: '>=10'}
    hasBin: true

  normalize-path@3.0.0:
    resolution: {integrity: sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==}
    engines: {node: '>=0.10.0'}

  object-assign@4.1.1:
    resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
    engines: {node: '>=0.10.0'}

  object-inspect@1.13.4:
    resolution: {integrity: sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==}
    engines: {node: '>= 0.4'}

  on-finished@2.3.0:
    resolution: {integrity: sha512-ikqdkGAAyf/X/gPhXGvfgAytDZtDbr+bkNUJ0N9h5MI/dmdgCs3l6hoHrcUv41sRKew3jIwrp4qQDXiK99Utww==}
    engines: {node: '>= 0.8'}

  on-finished@2.4.1:
    resolution: {integrity: sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==}
    engines: {node: '>= 0.8'}

  on-headers@1.1.0:
    resolution: {integrity: sha512-737ZY3yNnXy37FHkQxPzt4UZ2UWPWiCZWLvFZ4fu5cueciegX0zGPnrlY6bwRg4FdQOe9YU8MkmJwGhoMybl8A==}
    engines: {node: '>= 0.8'}

  parseurl@1.3.3:
    resolution: {integrity: sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==}
    engines: {node: '>= 0.8'}

  path-to-regexp@0.1.12:
    resolution: {integrity: sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==}

  picomatch@2.3.1:
    resolution: {integrity: sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==}
    engines: {node: '>=8.6'}

  proxy-addr@2.0.7:
    resolution: {integrity: sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==}
    engines: {node: '>= 0.10'}

  pstree.remy@1.1.8:
    resolution: {integrity: sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==}

  punycode@2.3.1:
    resolution: {integrity: sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==}
    engines: {node: '>=6'}

  qs@6.13.0:
    resolution: {integrity: sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==}
    engines: {node: '>=0.6'}

  range-parser@1.2.1:
    resolution: {integrity: sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==}
    engines: {node: '>= 0.6'}

  raw-body@2.5.2:
    resolution: {integrity: sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==}
    engines: {node: '>= 0.8'}

  readdirp@3.6.0:
    resolution: {integrity: sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==}
    engines: {node: '>=8.10.0'}

  safe-buffer@5.1.2:
    resolution: {integrity: sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==}

  safe-buffer@5.2.1:
    resolution: {integrity: sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==}

  safer-buffer@2.1.2:
    resolution: {integrity: sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==}

  semver@7.7.3:
    resolution: {integrity: sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==}
    engines: {node: '>=10'}
    hasBin: true

  send@0.19.0:
    resolution: {integrity: sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==}
    engines: {node: '>= 0.8.0'}

  serve-static@1.16.2:
    resolution: {integrity: sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==}
    engines: {node: '>= 0.8.0'}

  setprototypeof@1.2.0:
    resolution: {integrity: sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==}

  side-channel-list@1.0.0:
    resolution: {integrity: sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==}
    engines: {node: '>= 0.4'}

  side-channel-map@1.0.1:
    resolution: {integrity: sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==}
    engines: {node: '>= 0.4'}

  side-channel-weakmap@1.0.2:
    resolution: {integrity: sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==}
    engines: {node: '>= 0.4'}

  side-channel@1.1.0:
    resolution: {integrity: sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==}
    engines: {node: '>= 0.4'}

  sift@16.0.1:
    resolution: {integrity: sha512-Wv6BjQ5zbhW7VFefWusVP33T/EM0vYikCaQ2qR8yULbsilAT8/wQaXvuQ3ptGLpoKx+lihJE3y2UTgKDyyNHZQ==}

  simple-update-notifier@2.0.0:
    resolution: {integrity: sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==}
    engines: {node: '>=10'}

  smart-buffer@4.2.0:
    resolution: {integrity: sha512-94hK0Hh8rPqQl2xXc3HsaBoOXKV20MToPkcXvwbISWLEs+64sBq5kFgn2kJDHb1Pry9yrP0dxrCI9RRci7RXKg==}
    engines: {node: '>= 6.0.0', npm: '>= 3.0.0'}

  socks@2.8.7:
    resolution: {integrity: sha512-HLpt+uLy/pxB+bum/9DzAgiKS8CX1EvbWxI4zlmgGCExImLdiad2iCwXT5Z4c9c3Eq8rP2318mPW2c+QbtjK8A==}
    engines: {node: '>= 10.0.0', npm: '>= 3.0.0'}

  sparse-bitfield@3.0.3:
    resolution: {integrity: sha512-kvzhi7vqKTfkh0PZU+2D2PIllw2ymqJKujUcyPMd9Y75Nv4nPbGJZXNhxsgdQab2BmlDct1YnfQCguEvHr7VsQ==}

  ssf@0.11.2:
    resolution: {integrity: sha512-+idbmIXoYET47hH+d7dfm2epdOMUDjqcB4648sTZ+t2JwoyBFL/insLfB/racrDmsKB3diwsDA696pZMieAC5g==}
    engines: {node: '>=0.8'}

  statuses@2.0.1:
    resolution: {integrity: sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==}
    engines: {node: '>= 0.8'}

  supports-color@5.5.0:
    resolution: {integrity: sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==}
    engines: {node: '>=4'}

  to-regex-range@5.0.1:
    resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
    engines: {node: '>=8.0'}

  toidentifier@1.0.1:
    resolution: {integrity: sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==}
    engines: {node: '>=0.6'}

  touch@3.1.1:
    resolution: {integrity: sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==}
    hasBin: true

  tr46@3.0.0:
    resolution: {integrity: sha512-l7FvfAHlcmulp8kr+flpQZmVwtu7nfRV7NZujtN0OqES8EL4O4e0qqzL0DC5gAvx/ZC/9lk6rhcUwYvkBnBnYA==}
    engines: {node: '>=12'}

  type-is@1.6.18:
    resolution: {integrity: sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==}
    engines: {node: '>= 0.6'}

  undefsafe@2.0.5:
    resolution: {integrity: sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==}

  undici-types@7.16.0:
    resolution: {integrity: sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==}

  unpipe@1.0.0:
    resolution: {integrity: sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==}
    engines: {node: '>= 0.8'}

  utils-merge@1.0.1:
    resolution: {integrity: sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==}
    engines: {node: '>= 0.4.0'}

  vary@1.1.2:
    resolution: {integrity: sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==}
    engines: {node: '>= 0.8'}

  webidl-conversions@7.0.0:
    resolution: {integrity: sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==}
    engines: {node: '>=12'}

  whatwg-url@11.0.0:
    resolution: {integrity: sha512-RKT8HExMpoYx4igMiVMY83lN6UeITKJlBQ+vR/8ZJ8OCdSiN3RwCq+9gH0+Xzj0+5IrM6i4j/6LuvzbZIQgEcQ==}
    engines: {node: '>=12'}

  wmf@1.0.2:
    resolution: {integrity: sha512-/p9K7bEh0Dj6WbXg4JG0xvLQmIadrner1bi45VMJTfnbVHsc7yIajZyoSoK60/dtVBs12Fm6WkUI5/3WAVsNMw==}
    engines: {node: '>=0.8'}

  word@0.3.0:
    resolution: {integrity: sha512-OELeY0Q61OXpdUfTp+oweA/vtLVg5VDOXh+3he3PNzLGG/y0oylSOC1xRVj0+l4vQ3tj/bB1HVHv1ocXkQceFA==}
    engines: {node: '>=0.8'}

  xlsx@0.18.5:
    resolution: {integrity: sha512-dmg3LCjBPHZnQp5/F/+nnTa+miPJxUXB6vtk42YjBBKayDNagxGEeIdWApkYPOf3Z3pm3k62Knjzp7lMeTEtFQ==}
    engines: {node: '>=0.8'}
    hasBin: true

snapshots:

  '@mongodb-js/saslprep@1.3.2':
    dependencies:
      sparse-bitfield: 3.0.3
    optional: true

  '@types/node@24.10.1':
    dependencies:
      undici-types: 7.16.0

  '@types/webidl-conversions@7.0.3': {}

  '@types/whatwg-url@8.2.2':
    dependencies:
      '@types/node': 24.10.1
      '@types/webidl-conversions': 7.0.3

  accepts@1.3.8:
    dependencies:
      mime-types: 2.1.35
      negotiator: 0.6.3

  adler-32@1.3.1: {}

  anymatch@3.1.3:
    dependencies:
      normalize-path: 3.0.0
      picomatch: 2.3.1

  array-flatten@1.1.1: {}

  balanced-match@1.0.2: {}

  basic-auth@2.0.1:
    dependencies:
      safe-buffer: 5.1.2

  bcryptjs@2.4.3: {}

  binary-extensions@2.3.0: {}

  body-parser@1.20.3:
    dependencies:
      bytes: 3.1.2
      content-type: 1.0.5
      debug: 2.6.9
      depd: 2.0.0
      destroy: 1.2.0
      http-errors: 2.0.0
      iconv-lite: 0.4.24
      on-finished: 2.4.1
      qs: 6.13.0
      raw-body: 2.5.2
      type-is: 1.6.18
      unpipe: 1.0.0
    transitivePeerDependencies:
      - supports-color

  brace-expansion@1.1.12:
    dependencies:
      balanced-match: 1.0.2
      concat-map: 0.0.1

  braces@3.0.3:
    dependencies:
      fill-range: 7.1.1

  bson@5.5.1: {}

  buffer-equal-constant-time@1.0.1: {}

  bytes@3.1.2: {}

  call-bind-apply-helpers@1.0.2:
    dependencies:
      es-errors: 1.3.0
      function-bind: 1.1.2

  call-bound@1.0.4:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      get-intrinsic: 1.3.0

  cfb@1.2.2:
    dependencies:
      adler-32: 1.3.1
      crc-32: 1.2.2

  chokidar@3.6.0:
    dependencies:
      anymatch: 3.1.3
      braces: 3.0.3
      glob-parent: 5.1.2
      is-binary-path: 2.1.0
      is-glob: 4.0.3
      normalize-path: 3.0.0
      readdirp: 3.6.0
    optionalDependencies:
      fsevents: 2.3.3

  codepage@1.15.0: {}

  concat-map@0.0.1: {}

  content-disposition@0.5.4:
    dependencies:
      safe-buffer: 5.2.1

  content-type@1.0.5: {}

  cookie-signature@1.0.6: {}

  cookie@0.7.1: {}

  cors@2.8.5:
    dependencies:
      object-assign: 4.1.1
      vary: 1.1.2

  crc-32@1.2.2: {}

  debug@2.6.9:
    dependencies:
      ms: 2.0.0

  debug@4.4.3(supports-color@5.5.0):
    dependencies:
      ms: 2.1.3
    optionalDependencies:
      supports-color: 5.5.0

  depd@2.0.0: {}

  destroy@1.2.0: {}

  dotenv@16.6.1: {}

  dunder-proto@1.0.1:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-errors: 1.3.0
      gopd: 1.2.0

  ecdsa-sig-formatter@1.0.11:
    dependencies:
      safe-buffer: 5.2.1

  ee-first@1.1.1: {}

  encodeurl@1.0.2: {}

  encodeurl@2.0.0: {}

  es-define-property@1.0.1: {}

  es-errors@1.3.0: {}

  es-object-atoms@1.1.1:
    dependencies:
      es-errors: 1.3.0

  escape-html@1.0.3: {}

  etag@1.8.1: {}

  express-rate-limit@6.11.2(express@4.21.2):
    dependencies:
      express: 4.21.2

  express@4.21.2:
    dependencies:
      accepts: 1.3.8
      array-flatten: 1.1.1
      body-parser: 1.20.3
      content-disposition: 0.5.4
      content-type: 1.0.5
      cookie: 0.7.1
      cookie-signature: 1.0.6
      debug: 2.6.9
      depd: 2.0.0
      encodeurl: 2.0.0
      escape-html: 1.0.3
      etag: 1.8.1
      finalhandler: 1.3.1
      fresh: 0.5.2
      http-errors: 2.0.0
      merge-descriptors: 1.0.3
      methods: 1.1.2
      on-finished: 2.4.1
      parseurl: 1.3.3
      path-to-regexp: 0.1.12
      proxy-addr: 2.0.7
      qs: 6.13.0
      range-parser: 1.2.1
      safe-buffer: 5.2.1
      send: 0.19.0
      serve-static: 1.16.2
      setprototypeof: 1.2.0
      statuses: 2.0.1
      type-is: 1.6.18
      utils-merge: 1.0.1
      vary: 1.1.2
    transitivePeerDependencies:
      - supports-color

  fill-range@7.1.1:
    dependencies:
      to-regex-range: 5.0.1

  finalhandler@1.3.1:
    dependencies:
      debug: 2.6.9
      encodeurl: 2.0.0
      escape-html: 1.0.3
      on-finished: 2.4.1
      parseurl: 1.3.3
      statuses: 2.0.1
      unpipe: 1.0.0
    transitivePeerDependencies:
      - supports-color

  forwarded@0.2.0: {}

  frac@1.1.2: {}

  fresh@0.5.2: {}

  fsevents@2.3.3:
    optional: true

  function-bind@1.1.2: {}

  get-intrinsic@1.3.0:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-define-property: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      function-bind: 1.1.2
      get-proto: 1.0.1
      gopd: 1.2.0
      has-symbols: 1.1.0
      hasown: 2.0.2
      math-intrinsics: 1.1.0

  get-proto@1.0.1:
    dependencies:
      dunder-proto: 1.0.1
      es-object-atoms: 1.1.1

  glob-parent@5.1.2:
    dependencies:
      is-glob: 4.0.3

  gopd@1.2.0: {}

  has-flag@3.0.0: {}

  has-symbols@1.1.0: {}

  hasown@2.0.2:
    dependencies:
      function-bind: 1.1.2

  helmet@7.2.0: {}

  http-errors@2.0.0:
    dependencies:
      depd: 2.0.0
      inherits: 2.0.4
      setprototypeof: 1.2.0
      statuses: 2.0.1
      toidentifier: 1.0.1

  iconv-lite@0.4.24:
    dependencies:
      safer-buffer: 2.1.2

  ignore-by-default@1.0.1: {}

  inherits@2.0.4: {}

  ip-address@10.1.0: {}

  ipaddr.js@1.9.1: {}

  is-binary-path@2.1.0:
    dependencies:
      binary-extensions: 2.3.0

  is-extglob@2.1.1: {}

  is-glob@4.0.3:
    dependencies:
      is-extglob: 2.1.1

  is-number@7.0.0: {}

  jsonwebtoken@9.0.2:
    dependencies:
      jws: 3.2.2
      lodash.includes: 4.3.0
      lodash.isboolean: 3.0.3
      lodash.isinteger: 4.0.4
      lodash.isnumber: 3.0.3
      lodash.isplainobject: 4.0.6
      lodash.isstring: 4.0.1
      lodash.once: 4.1.1
      ms: 2.1.3
      semver: 7.7.3

  jwa@1.4.2:
    dependencies:
      buffer-equal-constant-time: 1.0.1
      ecdsa-sig-formatter: 1.0.11
      safe-buffer: 5.2.1

  jws@3.2.2:
    dependencies:
      jwa: 1.4.2
      safe-buffer: 5.2.1

  kareem@2.5.1: {}

  lodash.includes@4.3.0: {}

  lodash.isboolean@3.0.3: {}

  lodash.isinteger@4.0.4: {}

  lodash.isnumber@3.0.3: {}

  lodash.isplainobject@4.0.6: {}

  lodash.isstring@4.0.1: {}

  lodash.once@4.1.1: {}

  math-intrinsics@1.1.0: {}

  media-typer@0.3.0: {}

  memory-pager@1.5.0:
    optional: true

  merge-descriptors@1.0.3: {}

  methods@1.1.2: {}

  mime-db@1.52.0: {}

  mime-types@2.1.35:
    dependencies:
      mime-db: 1.52.0

  mime@1.6.0: {}

  minimatch@3.1.2:
    dependencies:
      brace-expansion: 1.1.12

  mongodb-connection-string-url@2.6.0:
    dependencies:
      '@types/whatwg-url': 8.2.2
      whatwg-url: 11.0.0

  mongodb@5.9.2:
    dependencies:
      bson: 5.5.1
      mongodb-connection-string-url: 2.6.0
      socks: 2.8.7
    optionalDependencies:
      '@mongodb-js/saslprep': 1.3.2

  mongoose@7.8.7:
    dependencies:
      bson: 5.5.1
      kareem: 2.5.1
      mongodb: 5.9.2
      mpath: 0.9.0
      mquery: 5.0.0
      ms: 2.1.3
      sift: 16.0.1
    transitivePeerDependencies:
      - '@aws-sdk/credential-providers'
      - '@mongodb-js/zstd'
      - kerberos
      - mongodb-client-encryption
      - snappy
      - supports-color

  morgan@1.10.1:
    dependencies:
      basic-auth: 2.0.1
      debug: 2.6.9
      depd: 2.0.0
      on-finished: 2.3.0
      on-headers: 1.1.0
    transitivePeerDependencies:
      - supports-color

  mpath@0.9.0: {}

  mquery@5.0.0:
    dependencies:
      debug: 4.4.3(supports-color@5.5.0)
    transitivePeerDependencies:
      - supports-color

  ms@2.0.0: {}

  ms@2.1.3: {}

  negotiator@0.6.3: {}

  nodemon@3.1.11:
    dependencies:
      chokidar: 3.6.0
      debug: 4.4.3(supports-color@5.5.0)
      ignore-by-default: 1.0.1
      minimatch: 3.1.2
      pstree.remy: 1.1.8
      semver: 7.7.3
      simple-update-notifier: 2.0.0
      supports-color: 5.5.0
      touch: 3.1.1
      undefsafe: 2.0.5

  normalize-path@3.0.0: {}

  object-assign@4.1.1: {}

  object-inspect@1.13.4: {}

  on-finished@2.3.0:
    dependencies:
      ee-first: 1.1.1

  on-finished@2.4.1:
    dependencies:
      ee-first: 1.1.1

  on-headers@1.1.0: {}

  parseurl@1.3.3: {}

  path-to-regexp@0.1.12: {}

  picomatch@2.3.1: {}

  proxy-addr@2.0.7:
    dependencies:
      forwarded: 0.2.0
      ipaddr.js: 1.9.1

  pstree.remy@1.1.8: {}

  punycode@2.3.1: {}

  qs@6.13.0:
    dependencies:
      side-channel: 1.1.0

  range-parser@1.2.1: {}

  raw-body@2.5.2:
    dependencies:
      bytes: 3.1.2
      http-errors: 2.0.0
      iconv-lite: 0.4.24
      unpipe: 1.0.0

  readdirp@3.6.0:
    dependencies:
      picomatch: 2.3.1

  safe-buffer@5.1.2: {}

  safe-buffer@5.2.1: {}

  safer-buffer@2.1.2: {}

  semver@7.7.3: {}

  send@0.19.0:
    dependencies:
      debug: 2.6.9
      depd: 2.0.0
      destroy: 1.2.0
      encodeurl: 1.0.2
      escape-html: 1.0.3
      etag: 1.8.1
      fresh: 0.5.2
      http-errors: 2.0.0
      mime: 1.6.0
      ms: 2.1.3
      on-finished: 2.4.1
      range-parser: 1.2.1
      statuses: 2.0.1
    transitivePeerDependencies:
      - supports-color

  serve-static@1.16.2:
    dependencies:
      encodeurl: 2.0.0
      escape-html: 1.0.3
      parseurl: 1.3.3
      send: 0.19.0
    transitivePeerDependencies:
      - supports-color

  setprototypeof@1.2.0: {}

  side-channel-list@1.0.0:
    dependencies:
      es-errors: 1.3.0
      object-inspect: 1.13.4

  side-channel-map@1.0.1:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      object-inspect: 1.13.4

  side-channel-weakmap@1.0.2:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      object-inspect: 1.13.4
      side-channel-map: 1.0.1

  side-channel@1.1.0:
    dependencies:
      es-errors: 1.3.0
      object-inspect: 1.13.4
      side-channel-list: 1.0.0
      side-channel-map: 1.0.1
      side-channel-weakmap: 1.0.2

  sift@16.0.1: {}

  simple-update-notifier@2.0.0:
    dependencies:
      semver: 7.7.3

  smart-buffer@4.2.0: {}

  socks@2.8.7:
    dependencies:
      ip-address: 10.1.0
      smart-buffer: 4.2.0

  sparse-bitfield@3.0.3:
    dependencies:
      memory-pager: 1.5.0
    optional: true

  ssf@0.11.2:
    dependencies:
      frac: 1.1.2

  statuses@2.0.1: {}

  supports-color@5.5.0:
    dependencies:
      has-flag: 3.0.0

  to-regex-range@5.0.1:
    dependencies:
      is-number: 7.0.0

  toidentifier@1.0.1: {}

  touch@3.1.1: {}

  tr46@3.0.0:
    dependencies:
      punycode: 2.3.1

  type-is@1.6.18:
    dependencies:
      media-typer: 0.3.0
      mime-types: 2.1.35

  undefsafe@2.0.5: {}

  undici-types@7.16.0: {}

  unpipe@1.0.0: {}

  utils-merge@1.0.1: {}

  vary@1.1.2: {}

  webidl-conversions@7.0.0: {}

  whatwg-url@11.0.0:
    dependencies:
      tr46: 3.0.0
      webidl-conversions: 7.0.0

  wmf@1.0.2: {}

  word@0.3.0: {}

  xlsx@0.18.5:
    dependencies:
      adler-32: 1.3.1
      cfb: 1.2.2
      codepage: 1.15.0
      crc-32: 1.2.2
      ssf: 0.11.2
      wmf: 1.0.2
      word: 0.3.0



===== FILE: C:\Users\crist\OneDrive\Documents\GitHub\bot-sales\bot-sales-backend\server.js =====
// server.js
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import helmet from "helmet";
import morgan from "morgan";
import rateLimit from "express-rate-limit";
import connectDB from "./src/config/db.js";

dotenv.config();

// 2. Configurar la Zona Horaria (Fallback a Bogotá si no está en el .env)
process.env.TZ = process.env.TZ || 'America/Bogota';

await connectDB();

import authRoutes from "./src/routes/auth.routes.js";
import userRoutes from "./src/routes/user.routes.js";
import productRoutes from "./src/routes/product.routes.js";
import categoryRoutes from "./src/routes/category.routes.js";
import saleRoutes from "./src/routes/sale.routes.js";
import cartRoutes from "./src/routes/cart.routes.js";
import convoRoutes from "./src/routes/conversation.routes.js";
import chatbotRoutes from "./src/routes/chatbot.routes.js";

const app = express();

app.use(helmet());
app.use(cors({ origin: process.env.FRONTEND_URL || "http://localhost:5173", credentials: true }));
app.use(express.json());
app.use(morgan("dev"));

// mark source (web, telegram, n8n)
app.use((req, res, next) => {
    req.requestSource = req.headers["x-request-source"] || req.body?.source || "web";
    next();
});

// rate limit auth
const authLimiter = rateLimit({ windowMs: 60 * 1000, max: 10 });
app.use("/api/auth", authLimiter);

// routes
app.use("/api/auth", authRoutes);
app.use("/api/users", userRoutes);
app.use("/api/products", productRoutes);
app.use("/api/categories", categoryRoutes);
app.use("/api/sales", saleRoutes);
app.use("/api/cart", cartRoutes);
app.use("/api/conversations", convoRoutes);
app.use("/api/chatbot", chatbotRoutes);

app.get("/", (req, res) => res.json({ ok: true }));

app.use((err, req, res, next) => {
    console.error("Unhandled Error:", err);
    res.status(500).json({ message: "Internal server error" });
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => console.log(`🚀 Server running on port ${PORT}`));



